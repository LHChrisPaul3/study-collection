## 算法图解笔记

### 1.二分查找

> 二分查找这个算法主要是这样描述的：其输入是一个**有序**的元素列表（这里的有序很重要），如果要查找的元素包含在列表中，二分查找返回其位置，否则返回 null。

> 一般而言，对于包含 n 个元素的列表，用二分查找最多需要 log2 n步，而简单查找最多需要n步，例如如果要在字典中查找一个单词，而该字典包含240000个单词，使用简单查找将需要240000步，而使用二分查找时，每次排除一半单词，直到最后只剩下一个单词，最多需要18步就可以了。

### 2.大O表示法

> 大O标识法是一种特殊的表示法，指出了算法的速度有多快。

> 算法的运行时间以不同的速度增加，例如检查100个元素使用简单查找需要100次查找，使用二分查找需要查找7（log2 100）次左右，但是当需要查找1亿个元素的时候则两个算法的时间差别就是非常非常大的了。

#### 一些常见的大O运行时间

> 下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。
- O(log n)，也叫对数时间，这样的算法包括二分查找。
- O(n)，也叫线性时间，这样的算法包括简单查找。
- O(n * log n),这样的算法包括快速排序（一种速度较快的排序算法）。
- O(n²),这样的算法包括选择排序（一种速度较慢的排序算法）。
- O(n!),这样的算法包括旅行商问题的解决方案（一种非常慢的算法）。

#### 注意事项

- 算法的运行时间并不以秒为单位
- 算法运行时间是从增速的角度度量的
- 算法运行时间用大O表示法表示

### 3.选择排序

> 链表中的元素可存储在内存的任何地方，其中每个元素都存储了下一个元素的地址

> 数组的元素都在一起

> 数组的读取速度很快

> 链表的插入和删除速度很快

### 4.递归

> 递归指的就是调用自己的函数

> 编写递归函数时，必须告诉它何时停止递归，因此，每个递归函数都有两部分：基线条件和递归条件，递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而可以跳出循环避免无限循环。

```
 def countdown(i):
    print i
    if i <= 0:   <==== 基线条件
        return
    else:        <==== 递归条件
        countdown(i-1)    

```

#### 栈

> 例如插入的待办事项放在清单的最前面，读取待办事项的时候，你只读取最上面的那个，并将其删除，因此这个待办事项清单只有两种操作：压入（插入）和弹出（删除并读取）。

> 所有的函数调用都进入调用栈。

### 5.快速排序

> 践行**分而治之（divide and conquer，D&C）-一种著名的递归式问题解决方法**

> 有待进一步理解

### 6.散列表

> 散列表是最有用的基本数据结构之一，其实类似于js中的object（对象）

> 假设你在一家杂货店上班，有顾客来买东西时，你需要在一个本子中查找价格，如果本子的内容不是按照字母顺序排列的，你需要使用简单查找来找到，需要的时间是O(n),如果本子的内容是按字母顺序排列的，可以使用二分查找来找出，需要的时间是O(log n)。当你使用散列表的时候需要的时间只需要O(1)，这样带来的性能提升随着数量的增加是非常显著的。

#### 散列函数

> 散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字。换一种专业术语来表示的话，可以说是“将输入映射到数字”。

> 散列函数必须满足一些要求
> - 它必须是一致的。例如，假设你输入apple时得到的是4，那么每次输入apple时，得到的都必须为4。如果不是这样，散列表将毫无用处。
> - 它应将不同的输入映射到不同的数字，例如，如果一个散列函数不管输入是什么都返回1，那么它就不是好的散列函数，最理想的情况是，将不同的输入映射到不同的数字。

> 散列函数准确地指出了价格的存储位置，你根本不用查找，之所以能够这样，具体原因如下：
> - 散列函数总是将同样的输入映射到相同的索引，每次你输入`avocado`，得到的都是同一个数字。
> - 散列函数将不同的输入映射到不同的索引。
> - 散列函数知道数组有多大，只返回有效的索引。

> 应用案例
> - 将散列表用于查找，模拟映射关系
> - 防止重复
> - 将散列表用作缓存，缓存/记住数据，以免服务器再通过处理来生成它们

> 简要小结
> - 散列表的查找、插入和删除速度都非常快
> - 散列表适合用于模拟映射关系
> - 散列表可用于缓存数据
> - 散列表非常适合于用于防止重复

### 7.广度优先搜索

> 广度优先搜索让你能够找出两样东西之间的最短距离，不过最短距离的含义有很多，例如
> - 编写国际跳棋AI，计算最少走多少步就可获胜
> - 编写拼写检查器，计算最少编辑多少个地方就可将错拼的单词改成正确的单词，如将READED改为READER需要编辑一个地方
> - 根据你的人际关系网络找到关系最近的医生

#### 队列

> 队列的工作原理与现实生活中的队列完全相同，假设你与朋友一起在公交车站排队，如果你排在他前面，你将先上车，队列的工作原理与此相同，队列类似于栈，你不能随机地访问队列中的元素。队列只支持两种操作：入队和出队。
>
> 队列是一种先进先出的数据结构，而栈是一种后进先出的数据结构。

> 简要小结
> - 广度优先搜索指出是否有从A到B的路径，如果有，广度优先搜索将找出最短路径
> - 面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来解决问题
> - 有向图中的边为箭头，箭头的方向指向了关系的方向，例如，rama-->adit表示rama欠adit钱
> - 无向图中的边不带箭头，其中的关系是双向的，例如，ross-->rachel表示“ross与rachel约会，而rachel也与ross约会”
> - 你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列
> - 对于检查过的人，务必不要再去检查，否则可能导致无限循环

### 8.狄克斯特拉算法

> 狄克斯特拉算法包含4个步骤
> - 找出“最便宜”的节点，即可在最短时间内到达的节点。
> - 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销
> - 重复这个过程，直到对图中的每个节点都这样做了
> - 计算最终路径

> 狄克斯特拉算法用于每条边都有关联数字的图，这些数字成为权重
> 带权重的图称为加权图，不带权重的图称为非加权图
> 要计算非加权图中的最短路径，可使用广度优先搜索，要计算加权图中的最短路径，可使用狄克斯特拉算法

### 9.贪婪算法

> 例如教室调度问题，贪婪算法就是你每步都选择局部最优解，最终得到的就是全局最优解

> 如果要找出经由指定几个点的最短路径，就是旅行商问题-NP完全问题，可以通过一下几点来判断是否是NP完全问题：
> - 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度就会变得非常慢
> - 涉及“所有组合”的问题通常是NP完全问题
> - 不能将问题分为小问题，必须考虑各种可能的情况，这可能是NP完全问题
> - 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题
> - 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题

> - 贪婪算法寻找局部最优解，企图以这种方式获得全局最优解
> - 对于NP完全问题，还没有找到快速解决方案
> - 面临NP完全问题，最佳的做法是使用近似算法
> - 贪婪算法易于实现、运行速度快，是不错的近似算法

### 10.动态规划

> - 需要在给定约束条件下优化某种指标时，动态规划很有用
> - 问题可分散为离散子问题时，可使用动态规划来解决
> - 每种动态规划解决方案都涉及网格
> - 单元格中的值通常就是你要优化的值
> - 每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题
> - 没有放之四海皆准的计算动态规划解决方案的公式

### 11.K最近邻算法

> K最近邻算法可以用于创建推荐系统