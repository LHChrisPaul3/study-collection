## 算法图解笔记

### 二分查找

> 二分查找这个算法主要是这样描述的：其输入是一个**有序**的元素列表（这里的有序很重要），如果要查找的元素包含在列表中，二分查找返回其位置，否则返回 null。

> 一般而言，对于包含 n 个元素的列表，用二分查找最多需要 log2 n步，而简单查找最多需要n步，例如如果要在字典中查找一个单词，而该字典包含240000个单词，使用简单查找将需要240000步，而使用二分查找时，每次排除一半单词，直到最后只剩下一个单词，最多需要18步就可以了。

### 大O表示法

> 大O标识法是一种特殊的表示法，指出了算法的速度有多快。

> 算法的运行时间以不同的速度增加，例如检查100个元素使用简单查找需要100次查找，使用二分查找需要查找7（log2 100）次左右，但是当需要查找1亿个元素的时候则两个算法的时间差别就是非常非常大的了。

#### 一些常见的大O运行时间

> 下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。
- O(log n)，也叫对数时间，这样的算法包括二分查找。
- O(n)，也叫线性时间，这样的算法包括简单查找。
- O(n * log n),这样的算法包括快速排序（一种速度较快的排序算法）。
- O(n²),这样的算法包括选择排序（一种速度较慢的排序算法）。
- O(n!),这样的算法包括旅行商问题的解决方案（一种非常慢的算法）。

#### 注意事项

- 算法的运行时间并不以秒为单位
- 算法运行时间是从增速的角度度量的
- 算法运行时间用大O表示法表示

### 选择排序

> 链表中的元素可存储在内存的任何地方，其中每个元素都存储了下一个元素的地址

> 数组的元素都在一起

> 数组的读取速度很快

> 链表的插入和删除速度很快

### 递归

> 递归指的就是调用自己的函数

> 编写递归函数时，必须告诉它何时停止递归，因此，每个递归函数都有两部分：基线条件和递归条件，递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而可以跳出循环避免无限循环。

```
 def countdown(i):
    print i
    if i <= 0:   <==== 基线条件
        return
    else:        <==== 递归条件
        countdown(i-1)    

```

#### 栈

> 例如插入的待办事项放在清单的最前面，读取待办事项的时候，你只读取最上面的那个，并将其删除，因此这个待办事项清单只有两种操作：压入（插入）和弹出（删除并读取）。

> 所有的函数调用都进入调用栈。

### 快速排序

> 践行**分而治之（divide and conquer，D&C）-一种著名的递归式问题解决方法**

> 